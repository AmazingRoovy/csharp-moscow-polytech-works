#pragma config(Sensor, S3,     LightSensor,    sensorLightInactive)
#pragma config(Sensor, S4,     SonarSensor,    sensorSONAR)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          LeftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          RightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int turns_number = 0;
int num_blacks = 0;

void turnRight()
{
	motor[motorB] = 60;
	motor[motorC] = -60;
}

void turnLeft()
{
	motor[motorB] = -60;
	motor[motorC] = 60;
}

// tnum = +1 : LEFT
// tnum = -1 : RIGHT
void turn(int tnum)
{
	const float k = 200.0 / 90.0;
	volatile float t = 90.0 * k;

	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;

	while(abs(nMotorEncoder[motorB]) <= t || abs(nMotorEncoder[motorC]) <= t)
	{
		if (tnum == 1)
			turnLeft();
		else if (tnum == -1)
			turnRight();
	}
}

task main()
{
	while (true)
	{
		// To overcome the first black line - in the START box!
		if (num_blacks == 0 && SensorValue(LightSensor) > 70)
		{
			num_blacks += 1;
			motor[motorB] = 80;
			motor[motorC] = 80;
			wait1Msec(1000);
		}
		if (num_blacks != 0 && SensorValue(LightSensor) > 70)
		{
			motor[motorB] = 80;
			motor[motorC] = 80;
		}
		else
		{
			motor[motorB] = 0;
			motor[motorC] = 0;
			wait1Msec(1000);

			if (turns_number != 3)
			{
				motor[motorB] = 80;
				motor[motorC] = 80;
				wait1Msec(1500);
				turn(-1);
				turns_number += 1;
			}
			else
			{
				motor[motorB] = 80;
				motor[motorC] = 80;
				wait1Msec(2500);
			}
		}
	}
}
